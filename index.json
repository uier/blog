[{"content":"前言 最近跟公司同事開了一個 Material Design 的讀書會，由我導讀 Elevation 的部分，在此紀錄一些當初讀這篇的筆記。\n原文： Material Design - Elevation 計算 Elevation  Elevation is the relative distance between two surfaces along the z-axis.\n  Elevation 是兩個平面在 z 軸上的相對距離，也就是高度差（或高度，若以 0dp 為基準）。 用 dp 這個單位測量，並通常（但不總是）會以陰影來繪製這段高度差。  在上圖中 A 和 B 兩張卡片都在 8dp 高的地方，但因為 B 後面有卡片 C，所以他的陰影只有 B 和 C 的高度差 4dp，而 A 則是 8dp 的陰影。\n當我們使用 CSS Library 在繪製陰影時，指定某元件有 2dp 的 Elevation 指的是他的陰影有 2dp 的厚度，與他當下的所在的高度無關。\n例如下圖是根據上圖所給予卡片的 Elevation，B 和 C 兩張卡片的 Elevation 都是 4dp。\nElevation 的功能簡介  使得物件擁有不同的高度：前後關係（上下層之分）。 有不同的高度能提示使用者他們是不同群體。 高度特別突出能吸引使用者的注意，反之則降低重要程度。  高度的繪製不僅有陰影，還可以透過填色或透明度來表現。\n使用陰影：Google News 的 Header\n使用填色：Youtube Mobile APP 的底部 Tab\n使用透明度：Youtube Desktop Website 的 Header\n後面有更詳細關於繪製的守則。\n靜止高度 Resting Elevation 手機上的靜止高度通常比桌面還要高，因為手機只有 Elevation 可以提示使用者你現在可以與這個元件互動，電腦有其他線索，例如 mouse hover。\n改變高度 動態偏移高度：在某個事件發生時元件改變的高度多寡。\n注意一致性，同樣的元件在整個應用中應有相同的靜止高度跟動態偏移高度。\n避免碰撞 根據 Material serface proterty，我們要避免穿透。\n於是在考量高度變化時，如果可能會有穿透，應讓被碰撞的物件消失或移出畫面。\n或是，覺得處理碰撞很麻煩的話可以在設計物件的位置時就先避免。\n繪製高度 Surface edges 凸顯出他的邊界，以告訴使用者他們是不同的物件。\nSurface overlap 凸顯他們正在重疊，也就是正所在不同高度。\n顏色對比、透明度可以展現出邊界跟重疊，但沒有展現高度差，不過也是表達他們前後關係的方式之一。\n距離感 使用 scrim（遮幕）遮著後方的內容可以提升遮幕上物件的高度，Dialog 最常使用，scrim 也有人稱 overlay, backdrop。\n陰影是能最細緻繪製高度的方法，它不必遮住其他內容，而且他可以表達出高度的量，兩平面間的距離是 5dp 高還是 8dp 高。\nElevation hierarchy 高度可以提示使用者：\n 資訊擺得愈高，他更重要 -\u0026gt; 把次要的東西擺在較低的位置。 吸引你的注意。 他主宰/控制較低高度的物件，如 Nav Bar, Header。  ","permalink":"https://blog.uier.tw/posts/20210914-elevation/","summary":"前言 最近跟公司同事開了一個 Material Design 的讀書會，由我導讀 Elevation 的部分，在此紀錄一些當初讀這篇的筆記。\n原文： Material Design - Elevation 計算 Elevation  Elevation is the relative distance between two surfaces along the z-axis.\n  Elevation 是兩個平面在 z 軸上的相對距離，也就是高度差（或高度，若以 0dp 為基準）。 用 dp 這個單位測量，並通常（但不總是）會以陰影來繪製這段高度差。  在上圖中 A 和 B 兩張卡片都在 8dp 高的地方，但因為 B 後面有卡片 C，所以他的陰影只有 B 和 C 的高度差 4dp，而 A 則是 8dp 的陰影。\n當我們使用 CSS Library 在繪製陰影時，指定某元件有 2dp 的 Elevation 指的是他的陰影有 2dp 的厚度，與他當下的所在的高度無關。\n例如下圖是根據上圖所給予卡片的 Elevation，B 和 C 兩張卡片的 Elevation 都是 4dp。","title":"Elevation in Material Design"},{"content":"前言 暑假回去公司實習時把 React 文件拿出來重新複習一次，順便在一些可以優化的地方使用 useMemo, useCallback，順手做個紀錄。\n被計算出來的狀態使用 useMemo 範例：計算按鈕何時應啟用 disabled 樣式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // Before: 自己寫 useEffect 去監聽依賴，在依賴變動時重新賦值 const [input, setInput] = useState(\u0026#39;\u0026#39;) const [isInputError, setIsInputError] = useState(false) const [isBtnDisabled, setIsBtnDisabled] = useState(true) useEffect(() =\u0026gt; { setIsBtnDisabled(input === \u0026#39;\u0026#39; || isInputError) }, [input, isInputError]) // ------------------------------------------------------ // After: 使用 useMemo  const [input, setInput] = useState(\u0026#39;\u0026#39;) const [isInputError, setIsInputError] = useState(false) const isBtnDisabled = useMemo(() =\u0026gt; { return (input === \u0026#39;\u0026#39; || isInputError) }, [input, isInputError])   useMemo 也可以 memorize 一個 functional component\n備註 同樣是監聽一些 state 去響應另一個 state，useMemo 的改寫我覺得可讀性較高。\n在 Vue.js 中，computed 屬性在做類似的事情，跟 React 不同的是，Vue.js 會自動追蹤計算的過程牽扯到哪些依賴，也就是不需要 dependency array。\n老實說，我翻了一些的 realworld example，卻不常看到 useMemo 被使用，還蠻令我驚訝的，我想 useMemo 應該不僅僅是這樣，有空會再尋找它在實際上是如何被使用的。\n參考資料：\n Hooks API 參考 Vue computed   Child Component 使用 React.memo 在 functional component 之前，React 提供 React.Component 和 React.PureComponent 來撰寫元件。\nReact.Component - React\n其中的差異在於，React.Component 需自行實作 shouldComponentUpdate 這個 function 來控制在 props 或 states 更新後是否需要重新 render，而 React.PureComponent 則沒有 shouldComponentUpdate，會以 shallow compare 的方式來比較舊的 props, states 和新的 props, states 來決定是否重新 render。\n在 functional component 中，當 parent component 觸發了重新渲染後，child component 也會重新 render，即使 props 沒有更新，若要避免這個問題，應該使用 React.memo 來包住 child component，他的用途是對於 props 做 shallow compare 來決定是否需要重新 render。\n另外，React.memo 可以在第二個參數傳遞一個自定義的 compare function，也就是保留了彈性，當不想要用其預設的 shallow compare，可以自已撰寫邏輯。\n範例：使用 React.memo 包裹子元件 我在 codesandbox 寫了一個範例，點進去後打開 console 可以發現，一開始初始化 App 後三個 component 都被渲染出來，之後在按下 add count1 按鈕時，Child1 跟 Child2 更新了，其中我們知道 Child1 有關注 count1 所以更新的合理，但 Child2 在這個情況下可以不必更新。 而用 React.memo 包起來的 MemoChild2 不會在每次父元件更新就跟著更新，而是做 shallow compare。\n使用時機 沒有使用 React.memo 可能會導致子元件做不必要的更新，但使用了 React.memo 也有 shallow compare 帶來的成本。\n 問題：shallow compare 的成本跟重新渲染的成本相比是不是小很多？\n 假如父元件將更新 N 次，而其中 M 次 props 並沒有更新，另外 N-M 次 props 有更新，那麼在 M 較小時我們應該不使用 React.memo，應該在 M 較大時使用。\n這樣來看，在 Container component 與 Presentational component 之間就不需要用 React.memo 包住 Presentational component，因為幾乎每次更新都是因為 props 更新。\n想一個相反的情境，例如表單 component 有較多狀態的情況，若有包含其他 component 如錯誤時要跳出來的 Alert，因為他只關心少數狀態，就可以使用 React.memo，或者用 useMemo。\n備註 在 Vue.js 中，子元件的重渲染機制預設就使用 shallow compare，目前看來在 React 中要自己 handle。\n參考資料：\n React 頂層 API 我該如何實作 shouldComponentUpdate？ 關於 props 的記憶，React Memo  ","permalink":"https://blog.uier.tw/posts/20210729-react-memorize/","summary":"前言 暑假回去公司實習時把 React 文件拿出來重新複習一次，順便在一些可以優化的地方使用 useMemo, useCallback，順手做個紀錄。\n被計算出來的狀態使用 useMemo 範例：計算按鈕何時應啟用 disabled 樣式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // Before: 自己寫 useEffect 去監聽依賴，在依賴變動時重新賦值 const [input, setInput] = useState(\u0026#39;\u0026#39;) const [isInputError, setIsInputError] = useState(false) const [isBtnDisabled, setIsBtnDisabled] = useState(true) useEffect(() =\u0026gt; { setIsBtnDisabled(input === \u0026#39;\u0026#39; || isInputError) }, [input, isInputError]) // ------------------------------------------------------ // After: 使用 useMemo  const [input, setInput] = useState(\u0026#39;\u0026#39;) const [isInputError, setIsInputError] = useState(false) const isBtnDisabled = useMemo(() =\u0026gt; { return (input === \u0026#39;\u0026#39; || isInputError) }, [input, isInputError])   useMemo 也可以 memorize 一個 functional component","title":"筆記 React.js 中 useMemo Hook"},{"content":"前言 我在上大學前的程式經驗只有程式競賽，到了大二才開始走進軟體開發，那時對於打造使用者介面有許多的憧憬而一頭栽進了前端開發的世界。\n在跟同學合作的許多 side projects 中我時常負責前端，在外頭的世界除了工程師，要創造有價值的產品還需要一個相當重要的角色———設計師，而我們這群忙著寫程式的資工系小鬼頭哪有人跳出來擔當設計師呢？於是 UI, UX 的責任通常就落到寫前端的人身上（苦笑）。\n雖然講得一副很委屈的樣子，但在過程中我開始著迷於研究如何做好 UI, UX，我覺得對於使用者來說，UI, UX 幾乎代表了前端的所有價值，哪個使用者會在乎你用了什麼很潮的技術或框架，或你的程式碼乾淨又美麗呢？\n總之，我想藉著這篇文章來記錄寫前端的這些時日，從一位工程師的角度是怎麼感受使用者體驗的問題。\n任何人都會碰到痛點 \u0008不是每個人都有設計的天賦，但是每個人都會感受到痛。\n你是否曾在寫程式時用了其他人寫的 Library，結果一邊寫一邊心裡想「Ｘ！這個 API 怎麼設計的這麼糟糕？」或在疫情期間進到每一家店都要填寫各種獨家設計的實名制表單？學校的某某系統好難用？說明書有看沒有懂？在百貨公司繞了半圈找不到廁所？\n這些讓你覺得「怎麼這麼蠢」的時刻，常常就是使用者體驗很糟的地方。\n上面的痛點你遇過幾個呢？很遺憾但也很慶幸生活中有這麼多不如意的事情，因為這些反例往往可以當作借鏡，去審視自己創造出來的東西。\n我在一開始設計前端時也是從模仿開始，除了可以從其他地方參考到好的設計，不好的設計讓我們\u0008避免重蹈覆轍，減少使用者的痛點。\n開發者也有很多時候在當使用者，我們使用 IDE、開發時使用第三方工具或框架、程式碼架構引入 Design Pattern，都是希望能讓開發者的體驗更好。\n解決需求並不容易 講到這些增進開發者體驗的工具，我們不妨回頭來想他們為什麼會被創造出來？\n例如撰寫 JavaScript 應用的開發者為何會選擇採用 TypeScript 呢？也許是希望在撰寫大型專案時可以有靜態型別檢查，結合其他工具產生基本的文件等等。或是引入 Design Pattern 的開發者希望可以解決一個他在程式碼中看到的問題。\n這些工具解決了開發者的需求，但事實上，十全十美的解法並不多，我們都知道有時候採用一些工具或方法會帶來副作用，也因此我們知道要衡量利弊，要做 trade-off。\n我初期在前端設計常犯的一個錯誤，就是我以為我知道怎麼解決使用者的需求，結果沒有思慮周全，導致我為了解決需求 A 而做出了功能 A，反而冒出了痛點 B, C, D 等著我再次解決。\n或者是使用者提出了一個需求，但其實這個需求是「他自己想好的其中一個解法」，有時候我們不見得要照做，我們可以在了解使用者背後真實的需求後幫忙思考是否有更好的解法。\n以下我要來分享我實際遇過的兩個情況。\n解法不只有一個 通常我們要解決一個需求可能會有非常多種方法，這時就會面臨到要如何做選擇。\n舉一個實際的例子，在學校的選課系統中，選擇「開課系所」的選單非常長，因為包含了 168 個系所\u0008，每次我都要來回滾動好幾次才可以定位到我要找的系所。\n在這裏我們要解決的需求是：幫助使用者快速的選到他要的目標。\n根據這個目標，我可能就有三種方法去做：\n若先不討論工程師實作的難易度，你會怎麼選擇呢？這三種解法分別有什麼優劣呢？\n這個問題沒有絕對的答案，或者說在不同的情境下會有不同的答案。\n\u0008\u0008\u0008在這裡我會選擇 A+C，我看到 Plan A 的缺點是必須要做輸入，會用到鍵盤，但因為我們可以預測使用這個選單的人應該是學生，對於用鍵盤打字不會太陌生，假如今天的情境，這個選單是給不熟悉鍵盤打字的族群使用，我可能就不會選擇 A。\n另外，第一次面對這個問題的我以為最佳解是 Plan B，後來發現如果使用者不知道他想找的系屬於哪一個學院，那就糗大了。\n在一些比較完整的產品團隊，大多會有專門的設計師在研究使用者，他們在設計前會做訪談、問卷調查以了解使用者的面貌，從客群的特性去找出較適合的方案，在產品上線之後一樣可以做調查、易用性測試，或做 A/B Testing 去比較不同的設計帶來的效益。\n使用者說的不一定是真的 圖片內容請參考：使用者是真的想要一匹更快的馬嗎？ 我參與的其中一個 side project 是程式作業的批改系統，有一次我跟 project 的使用者（系上教授）討論有什麼地方需要改進時，使用者明確地提出一個需求：「這邊可不可以幫我加一個功能？當我瀏覽完一份作業並批改後，就幫我跳出下一份作業，或自動幫我把網頁跳到下一份作業並將作業中的程式打開來\u0008。」\n工程師是懶惰的，一想到要做這個功能，連打開電腦的力氣都沒有了。這時讓我開始想：是不是有別的替代方案可以做到一樣的事，而不用做這麼麻煩的功能呢？對呀！使用者會這麼說正是因為現在要批改多份作業的過程不順暢，這才是真正的需求，只要能夠方便地批改多份作業，不見得要實作使用者口中的這個功能。\n雖然使用者是距離問題最近的人，但他不見得知道自己遇到的問題是什麼，並表達給開發者，也不見得能夠自行想出有效的解決方案，這時候我們如果可以幫使用者把關，找出他真正的需求，再由開發者以專業去設計解法，或許可以少走冤枉路，因為使用者叫你做的功能有可能做出來之後他自己也不喜歡。\n使用者體驗是同理出來的 以上分享的經驗，我覺得「保有同理心」就足以囊括上面的情況了。\n當工程師視程式可讀性為一種開發者體驗時，在撰寫的時候我們就會從他人的角度來審視，而開始思考：這個變數的命名精不精準？這個模組這樣拆分後續接手的人好不好理解？\n在做前端介面時，從使用者的角度去思考使用者會怎麼操作，試著描繪出流程，另外再多考量特別的情況，例如請求失敗、網速很慢、資料過多等，為使用者著想，能讓體驗有正面的提升。\n有時候在設計上也不必過於鑽牛角尖，在追求使用者體驗的過程不見得第一時間就要找到最佳解，有些解法不試試看也沒有人能保證適不適合，但就要做好日後會做修改、迭代的準備，不過當把使用者擺在第一順位的那天起，就已經逃不了改 Spec 的手掌心了。\n最後，如果你跟我一樣是個喜歡，或想嘗試設計的開發者，我覺得可以去讀一些 design system 的文件，例如 Google 推出的 Material Design。\n希望這篇分享能讓你對 UI/UX 有新的想法跟認識，歡迎來跟我討論哦！\n","permalink":"https://blog.uier.tw/posts/20210529-empathy-drives-ux/","summary":"前言 我在上大學前的程式經驗只有程式競賽，到了大二才開始走進軟體開發，那時對於打造使用者介面有許多的憧憬而一頭栽進了前端開發的世界。\n在跟同學合作的許多 side projects 中我時常負責前端，在外頭的世界除了工程師，要創造有價值的產品還需要一個相當重要的角色———設計師，而我們這群忙著寫程式的資工系小鬼頭哪有人跳出來擔當設計師呢？於是 UI, UX 的責任通常就落到寫前端的人身上（苦笑）。\n雖然講得一副很委屈的樣子，但在過程中我開始著迷於研究如何做好 UI, UX，我覺得對於使用者來說，UI, UX 幾乎代表了前端的所有價值，哪個使用者會在乎你用了什麼很潮的技術或框架，或你的程式碼乾淨又美麗呢？\n總之，我想藉著這篇文章來記錄寫前端的這些時日，從一位工程師的角度是怎麼感受使用者體驗的問題。\n任何人都會碰到痛點 \u0008不是每個人都有設計的天賦，但是每個人都會感受到痛。\n你是否曾在寫程式時用了其他人寫的 Library，結果一邊寫一邊心裡想「Ｘ！這個 API 怎麼設計的這麼糟糕？」或在疫情期間進到每一家店都要填寫各種獨家設計的實名制表單？學校的某某系統好難用？說明書有看沒有懂？在百貨公司繞了半圈找不到廁所？\n這些讓你覺得「怎麼這麼蠢」的時刻，常常就是使用者體驗很糟的地方。\n上面的痛點你遇過幾個呢？很遺憾但也很慶幸生活中有這麼多不如意的事情，因為這些反例往往可以當作借鏡，去審視自己創造出來的東西。\n我在一開始設計前端時也是從模仿開始，除了可以從其他地方參考到好的設計，不好的設計讓我們\u0008避免重蹈覆轍，減少使用者的痛點。\n開發者也有很多時候在當使用者，我們使用 IDE、開發時使用第三方工具或框架、程式碼架構引入 Design Pattern，都是希望能讓開發者的體驗更好。\n解決需求並不容易 講到這些增進開發者體驗的工具，我們不妨回頭來想他們為什麼會被創造出來？\n例如撰寫 JavaScript 應用的開發者為何會選擇採用 TypeScript 呢？也許是希望在撰寫大型專案時可以有靜態型別檢查，結合其他工具產生基本的文件等等。或是引入 Design Pattern 的開發者希望可以解決一個他在程式碼中看到的問題。\n這些工具解決了開發者的需求，但事實上，十全十美的解法並不多，我們都知道有時候採用一些工具或方法會帶來副作用，也因此我們知道要衡量利弊，要做 trade-off。\n我初期在前端設計常犯的一個錯誤，就是我以為我知道怎麼解決使用者的需求，結果沒有思慮周全，導致我為了解決需求 A 而做出了功能 A，反而冒出了痛點 B, C, D 等著我再次解決。\n或者是使用者提出了一個需求，但其實這個需求是「他自己想好的其中一個解法」，有時候我們不見得要照做，我們可以在了解使用者背後真實的需求後幫忙思考是否有更好的解法。\n以下我要來分享我實際遇過的兩個情況。\n解法不只有一個 通常我們要解決一個需求可能會有非常多種方法，這時就會面臨到要如何做選擇。\n舉一個實際的例子，在學校的選課系統中，選擇「開課系所」的選單非常長，因為包含了 168 個系所\u0008，每次我都要來回滾動好幾次才可以定位到我要找的系所。\n在這裏我們要解決的需求是：幫助使用者快速的選到他要的目標。\n根據這個目標，我可能就有三種方法去做：\n若先不討論工程師實作的難易度，你會怎麼選擇呢？這三種解法分別有什麼優劣呢？\n這個問題沒有絕對的答案，或者說在不同的情境下會有不同的答案。\n\u0008\u0008\u0008在這裡我會選擇 A+C，我看到 Plan A 的缺點是必須要做輸入，會用到鍵盤，但因為我們可以預測使用這個選單的人應該是學生，對於用鍵盤打字不會太陌生，假如今天的情境，這個選單是給不熟悉鍵盤打字的族群使用，我可能就不會選擇 A。\n另外，第一次面對這個問題的我以為最佳解是 Plan B，後來發現如果使用者不知道他想找的系屬於哪一個學院，那就糗大了。\n在一些比較完整的產品團隊，大多會有專門的設計師在研究使用者，他們在設計前會做訪談、問卷調查以了解使用者的面貌，從客群的特性去找出較適合的方案，在產品上線之後一樣可以做調查、易用性測試，或做 A/B Testing 去比較不同的設計帶來的效益。","title":"用同理心提升使用者體驗"},{"content":"前陣子，在修資料視覺化的同學寫作業遇到了一個問題，幫他解決後發現裡面有不少東西可以記錄下來。\n這一篇會分成三個部分\n 解決同學遇到的 bug：使用 d3-brush 後文字消失 了解 d3-brush 的行為 d3-axis 顏色的有趣發現  使用 d3-brush 後文字消失 我們要看的是下面這段程式，也可以到我的 observable 看 render 的結果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Demo\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/d3/5.0.0/d3.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/d3-brush/1.0.4/d3-brush.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;svg width=\u0026#34;100\u0026#34; height=\u0026#34;100\u0026#34;\u0026gt;\u0026lt;/svg\u0026gt; \u0026lt;script\u0026gt; const brush = d3.brush().extent([[0, 0], [100, 100]]); const svg = d3.select(\u0026#34;svg\u0026#34;); const g = svg.append(\u0026#34;g\u0026#34;); g.append(\u0026#34;text\u0026#34;) .attr(\u0026#34;transform\u0026#34;, \u0026#34;translate(0, 50)\u0026#34;) .attr(\u0026#34;font-size\u0026#34;, \u0026#34;15px\u0026#34;) .text(\u0026#34;Hello, world\u0026#34;); // try to comment the code below, and the text will reveal  g.call(brush); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   問題是這樣子，在\u0026lt;svg\u0026gt;內有一個群組元素\u0026lt;g\u0026gt;，裡面又有一個顯示Hello, world的文字元素\u0026lt;text\u0026gt;，當套用 d3-brush 後文字就消失不見了，若把g.call(brush)註解掉則文字就可以出現。\n打開瀏覽器的開發者工具，在 DOM 裡面還是可以找到\u0026lt;text\u0026gt;，但我們卻看不到他。\n\u0008不過眼尖就會發現上一層的\u0026lt;g\u0026gt;有 attributefill=\u0026quot;none\u0026quot;，因為我們沒有為\u0026lt;text\u0026gt;指定 fill 的顏色，而\u0026lt;g\u0026gt;這個元素會讓他的 children 繼承他的 attribute，所以造成\u0026lt;text\u0026gt;繼承了fill=\u0026quot;none\u0026quot;。關於\u0026lt;g\u0026gt;元素的說明可以看 MDN 的文件 。\n結論是，記得也要在\u0026lt;text\u0026gt;上設定 fill 屬性，就能順利顯示文字：\n1 2 3 4 5  g.append(\u0026#34;text\u0026#34;) .attr(\u0026#34;transform\u0026#34;, \u0026#34;translate(0, 50)\u0026#34;) .attr(\u0026#34;font-size\u0026#34;, \u0026#34;15px\u0026#34;) .attr(\u0026#34;fill\u0026#34;, \u0026#34;black\u0026#34;) .text(\u0026#34;Hello, world\u0026#34;);   d3-brush 的行為 那麼為何上層的\u0026lt;g\u0026gt;會是fill=\u0026quot;none\u0026quot;呢？\n當沒有套用 d3-brush 時，會看到\u0026lt;g\u0026gt;的 fill 是採用預設值黑色，並沒有被設定成fill=\u0026quot;none\u0026quot;，\u0026lt;text\u0026gt;則是因為繼承\u0026lt;g\u0026gt;而也顯示黑色。\n所以我們可以懷疑 d3-brush 把我們的\u0026lt;g\u0026gt;加上了fill=\u0026quot;none\u0026quot;。\n關於 d3-brush 的行為， 文件 裡頭有詳細的說明，主要是下列這段：\n The brush also creates the SVG elements necessary to display the brush selection and to receive input events for interaction. You can add, remove or modify these elements as desired to change the brush appearance; you can also apply stylesheets to modify the brush appearance. The structure of a two-dimensional brush is as follows:\n 1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;g class=\u0026#34;brush\u0026#34; fill=\u0026#34;none\u0026#34; pointer-events=\u0026#34;all\u0026#34; style=\u0026#34;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\u0026#34;\u0026gt; \u0026lt;rect class=\u0026#34;overlay\u0026#34; pointer-events=\u0026#34;all\u0026#34; cursor=\u0026#34;crosshair\u0026#34; x=\u0026#34;0\u0026#34; y=\u0026#34;0\u0026#34; width=\u0026#34;960\u0026#34; height=\u0026#34;500\u0026#34;\u0026gt;\u0026lt;/rect\u0026gt; \u0026lt;rect class=\u0026#34;selection\u0026#34; cursor=\u0026#34;move\u0026#34; fill=\u0026#34;#777\u0026#34; fill-opacity=\u0026#34;0.3\u0026#34; stroke=\u0026#34;#fff\u0026#34; shape-rendering=\u0026#34;crispEdges\u0026#34; x=\u0026#34;112\u0026#34; y=\u0026#34;194\u0026#34; width=\u0026#34;182\u0026#34; height=\u0026#34;83\u0026#34;\u0026gt;\u0026lt;/rect\u0026gt; \u0026lt;rect class=\u0026#34;handle handle--n\u0026#34; cursor=\u0026#34;ns-resize\u0026#34; x=\u0026#34;107\u0026#34; y=\u0026#34;189\u0026#34; width=\u0026#34;192\u0026#34; height=\u0026#34;10\u0026#34;\u0026gt;\u0026lt;/rect\u0026gt; \u0026lt;rect class=\u0026#34;handle handle--e\u0026#34; cursor=\u0026#34;ew-resize\u0026#34; x=\u0026#34;289\u0026#34; y=\u0026#34;189\u0026#34; width=\u0026#34;10\u0026#34; height=\u0026#34;93\u0026#34;\u0026gt;\u0026lt;/rect\u0026gt; \u0026lt;rect class=\u0026#34;handle handle--s\u0026#34; cursor=\u0026#34;ns-resize\u0026#34; x=\u0026#34;107\u0026#34; y=\u0026#34;272\u0026#34; width=\u0026#34;192\u0026#34; height=\u0026#34;10\u0026#34;\u0026gt;\u0026lt;/rect\u0026gt; \u0026lt;rect class=\u0026#34;handle handle--w\u0026#34; cursor=\u0026#34;ew-resize\u0026#34; x=\u0026#34;107\u0026#34; y=\u0026#34;189\u0026#34; width=\u0026#34;10\u0026#34; height=\u0026#34;93\u0026#34;\u0026gt;\u0026lt;/rect\u0026gt; \u0026lt;rect class=\u0026#34;handle handle--nw\u0026#34; cursor=\u0026#34;nwse-resize\u0026#34; x=\u0026#34;107\u0026#34; y=\u0026#34;189\u0026#34; width=\u0026#34;10\u0026#34; height=\u0026#34;10\u0026#34;\u0026gt;\u0026lt;/rect\u0026gt; \u0026lt;rect class=\u0026#34;handle handle--ne\u0026#34; cursor=\u0026#34;nesw-resize\u0026#34; x=\u0026#34;289\u0026#34; y=\u0026#34;189\u0026#34; width=\u0026#34;10\u0026#34; height=\u0026#34;10\u0026#34;\u0026gt;\u0026lt;/rect\u0026gt; \u0026lt;rect class=\u0026#34;handle handle--se\u0026#34; cursor=\u0026#34;nwse-resize\u0026#34; x=\u0026#34;289\u0026#34; y=\u0026#34;272\u0026#34; width=\u0026#34;10\u0026#34; height=\u0026#34;10\u0026#34;\u0026gt;\u0026lt;/rect\u0026gt; \u0026lt;rect class=\u0026#34;handle handle--sw\u0026#34; cursor=\u0026#34;nesw-resize\u0026#34; x=\u0026#34;107\u0026#34; y=\u0026#34;272\u0026#34; width=\u0026#34;10\u0026#34; height=\u0026#34;10\u0026#34;\u0026gt;\u0026lt;/rect\u0026gt; \u0026lt;/g\u0026gt;   套用後會改變\u0026lt;g\u0026gt;的屬性，另外總共會產生 10 個\u0026lt;rect\u0026gt;：\n \u0026lt;rect class=\u0026quot;overlay\u0026quot; ... /\u0026gt;會覆蓋整個\u0026lt;g\u0026gt;。 \u0026lt;rect class=\u0026quot;selection\u0026quot; ... /\u0026gt;是顯示 brush 後框選到的範圍，可以看到他有設定 fill 為灰色。 後面八個則是用來調整框選範圍大小的控制器，包含了四個邊跟四個角落。  也因此 d3-brush 設定了fill=\u0026quot;none\u0026quot;來隱藏這些\u0026lt;rect\u0026gt;，你也可以打開開發者工具手動把 fill 改成其他顏色看看會如何。在下面這張圖，我把\u0026lt;g\u0026gt;更改成fill=\u0026quot;red\u0026quot;。\n其實在幫同學看這個問題時有看到他嘗試寫了\u0026lt;text color=\u0026quot;black\u0026quot;\u0026gt;，然而 color 在 SVG 中並不是他所想的那樣，下一個部分會再提到 color 這個屬性。\n回頭去想，他之所以會需要在\u0026lt;g\u0026gt;裡面加\u0026lt;text\u0026gt;，是因為想在 x 軸以及 y 軸旁加上文字標籤，這讓我想到我們在 d3 建立 x 軸跟 y 軸時，也都是包含在\u0026lt;g\u0026gt;元素裡的，軸線用的是\u0026lt;path\u0026gt;、tick 跟 label 用的是\u0026lt;line\u0026gt;跟\u0026lt;text\u0026gt;，於是我好奇 d3-axis 是如何設定他們的 fill 屬性。\nd3-axis 的顏色設定 在翻 source code 時讓我發現一件有趣的事情，在 d3 v4（d3-axis \u0026lt;= v1.0.8）時，軸線跟 tick label 被寫死成fill=\u0026quot;#000\u0026quot;，可以看 這段 code ，我同時也附在下圖。\n1 2 3 4 5 6 7 8 9 10 11 12  path = path.merge(path.enter().insert(\u0026#34;path\u0026#34;, \u0026#34;.tick\u0026#34;) .attr(\u0026#34;class\u0026#34;, \u0026#34;domain\u0026#34;) .attr(\u0026#34;stroke\u0026#34;, \u0026#34;#000\u0026#34;)); line = line.merge(tickEnter.append(\u0026#34;line\u0026#34;) .attr(\u0026#34;stroke\u0026#34;, \u0026#34;#000\u0026#34;) .attr(x + \u0026#34;2\u0026#34;, k * tickSizeInner)); text = text.merge(tickEnter.append(\u0026#34;text\u0026#34;) .attr(\u0026#34;fill\u0026#34;, \u0026#34;#000\u0026#34;) .attr(x, k * spacing) .attr(\u0026#34;dy\u0026#34;, orient === top ? \u0026#34;0em\u0026#34; : orient === bottom ? \u0026#34;0.71em\u0026#34; : \u0026#34;0.32em\u0026#34;));   而後來，作者自己開了這個 issue 並更改成fill=\u0026quot;currentcolor\u0026quot;，如下圖。\ncurrentcolor 是什麼？ fill, stroke 這些設定顏色的屬性，除了可以設為一個顏色的 rgb 值、hex 值等，也可以設定為 currentcolor，如fill=\u0026quot;currentcolor\u0026quot;。\n而究竟他會設定成什麼顏色呢，答案是 color 這個屬性的顏色，若沒有設定 color 則會繼承 parent 的 color。\ncurrentcolor 讓我們在設定顏色時，可以透過上層的 color 來統一環境的顏色，不必單獨管理每個子元素的顏色。\n以上述提到 d3-axis 的 issue 來舉例，作者的考量是希望 axis 的顏色可以彈性的更改。若寫死成黑色，當背景色是深色的情況下，就需要靠開發者自己去重新設定顏色。\n我根據這個情境寫了一個 範例 ，讓大家可以對比這個改變的威力。\n","permalink":"https://blog.uier.tw/posts/20210516-d3-brush-fill-none/","summary":"前陣子，在修資料視覺化的同學寫作業遇到了一個問題，幫他解決後發現裡面有不少東西可以記錄下來。\n這一篇會分成三個部分\n 解決同學遇到的 bug：使用 d3-brush 後文字消失 了解 d3-brush 的行為 d3-axis 顏色的有趣發現  使用 d3-brush 後文字消失 我們要看的是下面這段程式，也可以到我的 observable 看 render 的結果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Demo\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/d3/5.0.0/d3.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/d3-brush/1.0.4/d3-brush.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;svg width=\u0026#34;100\u0026#34; height=\u0026#34;100\u0026#34;\u0026gt;\u0026lt;/svg\u0026gt; \u0026lt;script\u0026gt; const brush = d3.","title":"使用 d3-brush 後文字不見？了解 svg 的顏色設定"},{"content":"有鑑於自己不太擅長追根究底的，於是想透過做筆記的方式，來讓自己徹底了解一個陌生的知識。\n","permalink":"https://blog.uier.tw/posts/20210124-first-commit/","summary":"有鑑於自己不太擅長追根究底的，於是想透過做筆記的方式，來讓自己徹底了解一個陌生的知識。","title":"First commit"},{"content":"近期更新：\n我要大學畢業了！2022 年要到新竹讀交大資工碩～\n部落格不太常更新，堆了不少 draft\u0026hellip;，但我最近有一個新的 CV 頁面，歡迎造訪\n 我是于子緯，在網路上通常用 uier 或 TzuWei 這兩個名稱。\n臺南人，2018 年來臺北讀師大資工，對視覺的東西特別有興趣，雖然我不會畫畫，但我相信透過程式一樣能讓我創造出賞心悅目的事物。\n正在學習 javascript，心血來潮時會寫點別的，如果想知道我最近在寫什麼可以追蹤我的 GitHub 或 Facebook 。\n聯絡方式首頁在都有唷。\n對了，我也不知道 uier 怎麼唸，我都四個字母分開唸。\n三個在我生活中花最多時間做的事：\n 睡覺 耍廢 看 Youtube  三個在我\u0008生活中最有趣的事：\n 寫程式 吃美食 跟女朋友相處  ","permalink":"https://blog.uier.tw/about/","summary":"近期更新：\n我要大學畢業了！2022 年要到新竹讀交大資工碩～\n部落格不太常更新，堆了不少 draft\u0026hellip;，但我最近有一個新的 CV 頁面，歡迎造訪\n 我是于子緯，在網路上通常用 uier 或 TzuWei 這兩個名稱。\n臺南人，2018 年來臺北讀師大資工，對視覺的東西特別有興趣，雖然我不會畫畫，但我相信透過程式一樣能讓我創造出賞心悅目的事物。\n正在學習 javascript，心血來潮時會寫點別的，如果想知道我最近在寫什麼可以追蹤我的 GitHub 或 Facebook 。\n聯絡方式首頁在都有唷。\n對了，我也不知道 uier 怎麼唸，我都四個字母分開唸。\n三個在我生活中花最多時間做的事：\n 睡覺 耍廢 看 Youtube  三個在我\u0008生活中最有趣的事：\n 寫程式 吃美食 跟女朋友相處  ","title":"About ✨"},{"content":"","permalink":"https://blog.uier.tw/archive/","summary":"","title":"Archive"},{"content":"","permalink":"https://blog.uier.tw/search/","summary":"","title":"Search"}]