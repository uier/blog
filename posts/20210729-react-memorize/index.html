<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>筆記 React.js 中 useMemo Hook | TzuWei's Blog 🐠</title><meta name=keywords content="React.js"><meta name=description content="前言 暑假回去公司實習時把 React 文件拿出來重新複習一次，順便在一些可以優化的地方使用 useMemo, useCallback，順手做個紀錄。
被計算出來的狀態使用 useMemo 範例：計算按鈕何時應啟用 disabled 樣式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // Before: 自己寫 useEffect 去監聽依賴，在依賴變動時重新賦值 const [input, setInput] = useState('') const [isInputError, setIsInputError] = useState(false) const [isBtnDisabled, setIsBtnDisabled] = useState(true) useEffect(() => { setIsBtnDisabled(input === '' || isInputError) }, [input, isInputError]) // ------------------------------------------------------ // After: 使用 useMemo  const [input, setInput] = useState('') const [isInputError, setIsInputError] = useState(false) const isBtnDisabled = useMemo(() => { return (input === '' || isInputError) }, [input, isInputError])   useMemo 也可以 memorize 一個 functional component"><meta name=author content><link rel=canonical href=https://uier.github.io/blog/posts/20210729-react-memorize/><link href=/blog/assets/css/stylesheet.min.c076f7e57fc898d79896f01b86b45a2283c95da97e7afd41700b61e878931da3.css integrity="sha256-wHb35X/ImNeYlvAbhrRaIoPJXal+ev1BcAth6HiTHaM=" rel="preload stylesheet" as=style><link rel=icon href=https://uier.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://uier.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://uier.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://uier.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://uier.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><script async src="https://www.googletagmanager.com/gtag/js?id=G-EWHVMQWQYV"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-EWHVMQWQYV')</script><meta property="og:title" content="筆記 React.js 中 useMemo Hook"><meta property="og:description" content="前言 暑假回去公司實習時把 React 文件拿出來重新複習一次，順便在一些可以優化的地方使用 useMemo, useCallback，順手做個紀錄。
被計算出來的狀態使用 useMemo 範例：計算按鈕何時應啟用 disabled 樣式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // Before: 自己寫 useEffect 去監聽依賴，在依賴變動時重新賦值 const [input, setInput] = useState('') const [isInputError, setIsInputError] = useState(false) const [isBtnDisabled, setIsBtnDisabled] = useState(true) useEffect(() => { setIsBtnDisabled(input === '' || isInputError) }, [input, isInputError]) // ------------------------------------------------------ // After: 使用 useMemo  const [input, setInput] = useState('') const [isInputError, setIsInputError] = useState(false) const isBtnDisabled = useMemo(() => { return (input === '' || isInputError) }, [input, isInputError])   useMemo 也可以 memorize 一個 functional component"><meta property="og:type" content="article"><meta property="og:url" content="https://uier.github.io/blog/posts/20210729-react-memorize/"><meta property="article:published_time" content="2021-07-29T18:13:04+08:00"><meta property="article:modified_time" content="2021-07-29T18:13:04+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="筆記 React.js 中 useMemo Hook"><meta name=twitter:description content="前言 暑假回去公司實習時把 React 文件拿出來重新複習一次，順便在一些可以優化的地方使用 useMemo, useCallback，順手做個紀錄。
被計算出來的狀態使用 useMemo 範例：計算按鈕何時應啟用 disabled 樣式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // Before: 自己寫 useEffect 去監聽依賴，在依賴變動時重新賦值 const [input, setInput] = useState('') const [isInputError, setIsInputError] = useState(false) const [isBtnDisabled, setIsBtnDisabled] = useState(true) useEffect(() => { setIsBtnDisabled(input === '' || isInputError) }, [input, isInputError]) // ------------------------------------------------------ // After: 使用 useMemo  const [input, setInput] = useState('') const [isInputError, setIsInputError] = useState(false) const isBtnDisabled = useMemo(() => { return (input === '' || isInputError) }, [input, isInputError])   useMemo 也可以 memorize 一個 functional component"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"筆記 React.js 中 useMemo Hook","name":"筆記 React.js 中 useMemo Hook","description":"前言 暑假回去公司實習時把 React 文件拿出來重新複習一次，順便在一些可以優化的地方使用 useMemo, useCallback，順手做個紀錄。\n被計算出來的狀態使用 useMemo 範例：計算按鈕何時應啟用 disabled 樣式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // Before: …","keywords":["React.js"],"articleBody":"前言 暑假回去公司實習時把 React 文件拿出來重新複習一次，順便在一些可以優化的地方使用 useMemo, useCallback，順手做個紀錄。\n被計算出來的狀態使用 useMemo 範例：計算按鈕何時應啟用 disabled 樣式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // Before: 自己寫 useEffect 去監聽依賴，在依賴變動時重新賦值 const [input, setInput] = useState('') const [isInputError, setIsInputError] = useState(false) const [isBtnDisabled, setIsBtnDisabled] = useState(true) useEffect(() = { setIsBtnDisabled(input === '' || isInputError) }, [input, isInputError]) // ------------------------------------------------------ // After: 使用 useMemo  const [input, setInput] = useState('') const [isInputError, setIsInputError] = useState(false) const isBtnDisabled = useMemo(() = { return (input === '' || isInputError) }, [input, isInputError])   useMemo 也可以 memorize 一個 functional component\n備註 同樣是監聽一些 state 去響應另一個 state，useMemo 的改寫我覺得可讀性較高。\n在 Vue.js 中，computed 屬性在做類似的事情，跟 React 不同的是，Vue.js 會自動追蹤計算的過程牽扯到哪些依賴，也就是不需要 dependency array。\n老實說，我翻了一些的 realworld example，卻不常看到 useMemo 被使用，還蠻令我驚訝的，我想 useMemo 應該不僅僅是這樣，有空會再尋找它在實際上是如何被使用的。\n參考資料：\n Hooks API 參考 Vue computed   Child Component 使用 React.memo 在 functional component 之前，React 提供 React.Component 和 React.PureComponent 來撰寫元件。\nReact.Component - React\n其中的差異在於，React.Component 需自行實作 shouldComponentUpdate 這個 function 來控制在 props 或 states 更新後是否需要重新 render，而 React.PureComponent 則沒有 shouldComponentUpdate，會以 shallow compare 的方式來比較舊的 props, states 和新的 props, states 來決定是否重新 render。\n在 functional component 中，當 parent component 觸發了重新渲染後，child component 也會重新 render，即使 props 沒有更新，若要避免這個問題，應該使用 React.memo 來包住 child component，他的用途是對於 props 做 shallow compare 來決定是否需要重新 render。\n另外，React.memo 可以在第二個參數傳遞一個自定義的 compare function，也就是保留了彈性，當不想要用其預設的 shallow compare，可以自已撰寫邏輯。\n範例：使用 React.memo 包裹子元件 我在 codesandbox 寫了一個範例，點進去後打開 console 可以發現，一開始初始化 App 後三個 component 都被渲染出來，之後在按下 add count1 按鈕時，Child1 跟 Child2 更新了，其中我們知道 Child1 有關注 count1 所以更新的合理，但 Child2 在這個情況下可以不必更新。 而用 React.memo 包起來的 MemoChild2 不會在每次父元件更新就跟著更新，而是做 shallow compare。\n使用時機 沒有使用 React.memo 可能會導致子元件做不必要的更新，但使用了 React.memo 也有 shallow compare 帶來的成本。\n 問題：shallow compare 的成本跟重新渲染的成本相比是不是小很多？\n 假如父元件將更新 N 次，而其中 M 次 props 並沒有更新，另外 N-M 次 props 有更新，那麼在 M 較小時我們應該不使用 React.memo，應該在 M 較大時使用。\n這樣來看，在 Container component 與 Presentational component 之間就不需要用 React.memo 包住 Presentational component，因為幾乎每次更新都是因為 props 更新。\n想一個相反的情境，例如表單 component 有較多狀態的情況，若有包含其他 component 如錯誤時要跳出來的 Alert，因為他只關心少數狀態，就可以使用 React.memo，或者用 useMemo。\n備註 在 Vue.js 中，子元件的重渲染機制預設就使用 shallow compare，目前看來在 React 中要自己 handle。\n參考資料：\n React 頂層 API 我該如何實作 shouldComponentUpdate？ 關於 props 的記憶，React Memo  ","wordCount":"291","inLanguage":"en","datePublished":"2021-07-29T18:13:04+08:00","dateModified":"2021-07-29T18:13:04+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://uier.github.io/blog/posts/20210729-react-memorize/"},"publisher":{"@type":"Organization","name":"TzuWei's Blog 🐠","logo":{"@type":"ImageObject","url":"https://uier.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://uier.github.io/blog/ accesskey=h title="TzuWei's Blog 🐠 (Alt + H)">TzuWei's Blog 🐠</a>
<span class=logo-switches><span class=theme-toggle title="(Alt + T)"><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://uier.github.io/blog/ title=Home><span>Home</span></a></li><li><a href=https://uier.github.io/blog/about/ title=About><span>About</span></a></li><li><a href=https://uier.github.io/blog/archive/ title=Archive><span>Archive</span></a></li><li><a href=https://uier.github.io/blog/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://uier.github.io/blog/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://uier.github.io/blog/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>筆記 React.js 中 useMemo Hook</h1><div class=post-description></div><div class=post-meta>July 29, 2021</div></header><div class=post-content><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>暑假回去公司實習時把 React 文件拿出來重新複習一次，順便在一些可以優化的地方使用 <code>useMemo</code>, <code>useCallback</code>，順手做個紀錄。</p><h2 id=被計算出來的狀態使用-usememo>被計算出來的狀態使用 <code>useMemo</code><a hidden class=anchor aria-hidden=true href=#被計算出來的狀態使用-usememo>#</a></h2><h3 id=範例計算按鈕何時應啟用-disabled-樣式>範例：計算按鈕何時應啟用 disabled 樣式<a hidden class=anchor aria-hidden=true href=#範例計算按鈕何時應啟用-disabled-樣式>#</a></h3><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#6272a4>// Before: 自己寫 useEffect 去監聽依賴，在依賴變動時重新賦值
</span><span style=color:#6272a4></span><span style=color:#ff79c6>const</span> [input, setInput] <span style=color:#ff79c6>=</span> useState(<span style=color:#f1fa8c>&#39;&#39;</span>)
<span style=color:#ff79c6>const</span> [isInputError, setIsInputError] <span style=color:#ff79c6>=</span> useState(<span style=color:#ff79c6>false</span>)
<span style=color:#ff79c6>const</span> [isBtnDisabled, setIsBtnDisabled] <span style=color:#ff79c6>=</span> useState(<span style=color:#ff79c6>true</span>)

useEffect(() =&gt; {
  setIsBtnDisabled(input <span style=color:#ff79c6>===</span> <span style=color:#f1fa8c>&#39;&#39;</span> <span style=color:#ff79c6>||</span> isInputError)
}, [input, isInputError])

<span style=color:#6272a4>// ------------------------------------------------------
</span><span style=color:#6272a4>// After: 使用 useMemo
</span><span style=color:#6272a4></span>
<span style=color:#ff79c6>const</span> [input, setInput] <span style=color:#ff79c6>=</span> useState(<span style=color:#f1fa8c>&#39;&#39;</span>)
<span style=color:#ff79c6>const</span> [isInputError, setIsInputError] <span style=color:#ff79c6>=</span> useState(<span style=color:#ff79c6>false</span>)
<span style=color:#ff79c6>const</span> isBtnDisabled <span style=color:#ff79c6>=</span> useMemo(() =&gt; {
  <span style=color:#ff79c6>return</span> (input <span style=color:#ff79c6>===</span> <span style=color:#f1fa8c>&#39;&#39;</span> <span style=color:#ff79c6>||</span> isInputError)
}, [input, isInputError])
</code></pre></td></tr></table></div></div><p><code>useMemo</code> 也可以 memorize 一個 functional component</p><h3 id=備註>備註<a hidden class=anchor aria-hidden=true href=#備註>#</a></h3><p>同樣是監聽一些 state 去響應另一個 state，<code>useMemo</code> 的改寫我覺得可讀性較高。</p><p>在 Vue.js 中，<code>computed</code> 屬性在做類似的事情，跟 React 不同的是，Vue.js 會自動追蹤計算的過程牽扯到哪些依賴，也就是不需要 dependency array。</p><p>老實說，我翻了一些的 realworld example，卻不常看到 <code>useMemo</code> 被使用，還蠻令我驚訝的，我想 <code>useMemo</code> 應該不僅僅是這樣，有空會再尋找它在實際上是如何被使用的。</p><p>參考資料：</p><ul><li><a href=https://zh-hant.reactjs.org/docs/hooks-reference.html#usememo>Hooks API 參考</a></li><li><a href=https://v3.vuejs.org/guide/computed.html#basic-example>Vue computed</a></li></ul><hr><h2 id=child-component-使用-reactmemo>Child Component 使用 React.memo<a hidden class=anchor aria-hidden=true href=#child-component-使用-reactmemo>#</a></h2><p>在 functional component 之前，React 提供 <code>React.Component</code> 和 <code>React.PureComponent</code> 來撰寫元件。</p><p><a href=https://zh-hant.reactjs.org/docs/react-component.html>React.Component - React</a></p><p>其中的差異在於，<code>React.Component</code> 需自行實作 <code>shouldComponentUpdate</code> 這個 function 來控制在 props 或 states 更新後是否需要重新 render，而 <code>React.PureComponent</code> 則沒有 <code>shouldComponentUpdate</code>，會以 shallow compare 的方式來比較舊的 props, states 和新的 props, states 來決定是否重新 render。</p><p>在 functional component 中，當 parent component 觸發了重新渲染後，child component 也會重新 render，<strong>即使 props 沒有更新</strong>，若要避免這個問題，應該使用 <code>React.memo</code> 來包住 child component，他的用途是對於 props 做 shallow compare 來決定是否需要重新 render。</p><p>另外，<code>React.memo</code> 可以在第二個參數傳遞一個自定義的 compare function，也就是保留了彈性，當不想要用其預設的 shallow compare，可以自已撰寫邏輯。</p><h3 id=範例使用-reactmemo-包裹子元件>範例：使用 <code>React.memo</code> 包裹子元件<a hidden class=anchor aria-hidden=true href=#範例使用-reactmemo-包裹子元件>#</a></h3><p>我在 <a href=https://codesandbox.io/s/react-memo-7mhki>codesandbox</a> 寫了一個範例，點進去後打開 console 可以發現，一開始初始化 App 後三個 component 都被渲染出來，之後在按下 add count1 按鈕時，<code>Child1</code> 跟 <code>Child2</code> 更新了，其中我們知道 <code>Child1</code> 有關注 <code>count1</code> 所以更新的合理，但 <code>Child2</code> 在這個情況下可以不必更新。
而用 <code>React.memo</code> 包起來的 <code>MemoChild2</code> 不會在每次父元件更新就跟著更新，而是做 shallow compare。</p><h3 id=使用時機>使用時機<a hidden class=anchor aria-hidden=true href=#使用時機>#</a></h3><p>沒有使用 <code>React.memo</code> 可能會導致子元件做不必要的更新，但使用了 <code>React.memo</code> 也有 shallow compare 帶來的成本。</p><blockquote><p>問題：shallow compare 的成本跟重新渲染的成本相比是不是小很多？</p></blockquote><p>假如父元件將更新 N 次，而其中 M 次 props 並沒有更新，另外 N-M 次 props 有更新，那麼在 M 較小時我們應該不使用 <code>React.memo</code>，應該在 M 較大時使用。</p><p>這樣來看，在 Container component 與 Presentational component 之間就不需要用 <code>React.memo</code> 包住 Presentational component，因為幾乎每次更新都是因為 props 更新。</p><p>想一個相反的情境，例如表單 component 有較多狀態的情況，若有包含其他 component 如錯誤時要跳出來的 Alert，因為他只關心少數狀態，就可以使用 <code>React.memo</code>，或者用 <code>useMemo</code>。</p><h3 id=備註-1>備註<a hidden class=anchor aria-hidden=true href=#備註-1>#</a></h3><p>在 Vue.js 中，子元件的重渲染機制預設就使用 shallow compare，目前看來在 React 中要自己 handle。</p><p>參考資料：</p><ul><li><a href=https://zh-hant.reactjs.org/docs/react-api.html>React 頂層 API</a></li><li><a href=https://zh-hant.reactjs.org/docs/hooks-faq.html#how-do-i-implement-shouldcomponentupdate>我該如何實作 shouldComponentUpdate？</a></li><li><a href=https://ithelp.ithome.com.tw/articles/10240296>關於 props 的記憶，React Memo</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://uier.github.io/blog/tags/react.js/>React.js</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://uier.github.io/blog/>TzuWei's Blog 🐠</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/blog/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.replaceState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>